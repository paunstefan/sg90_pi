//! Raspberry Pi library for the SG90 servo
//!
//! The SG90 is a lightweight and cheap servo motor that can rotate aproxiamately
//! 180 degrees.
//!
//! Like many servo motors the rotation is controlled by a PWM signal, which
//! in this case will be generated by the PWM pins on the RPi (check the rppal crate for
//! more info on this).
//!
//! PWM signals have a frequency and a duty cycle, both can be measured in milliseconds.
//! The frequency is how long a whole cycle is, and the duty cycle represents how long
//! the voltage stays high.
//!
//! In the SG90's case, the operating frequency is 50Hz (20ms) and the duty cycle controls the
//! angle. 0.5ms for -90 degrees, 1.5ms for 0 degrees and 2.5ms for 90 degrees.
//!
//! # Usage
//! All you need to do to operate the motor is initialize it and
//! then set the desired angle (in degrees or radians).
//! ```rust,no_run
//! use std::{thread, time::Duration};
//! use sg90_pi::SG90;
//!
//! fn main() {
//!     let mut pin = SG90::new(rppal::pwm::Channel::Pwm0, 0.0).unwrap();
//!     pin.set_angle_deg(-90).unwrap();
//!     thread::sleep(Duration::from_millis(1s000));
//!     pin.set_angle_deg(90).unwrap();
//! }
//! ```
//!

#![deny(
    missing_docs,
    missing_debug_implementations,
    trivial_casts,
    unused_imports
)]
#![allow(clippy::needless_doctest_main)]

use rppal::pwm::{Channel, Polarity, Pwm};
use std::{
    f64::consts::PI,
    ops::{Add, Div, Mul, Sub},
};

// Constants
/// SG90 operating frequency - 50Hz
const FREQUENCY: f64 = 50.0;
const PERIOD: f64 = 1000.0 / FREQUENCY;

/// Minimum angle in radians
const ANGLE_MIN: f64 = -0.5 * PI;
/// Maximum angle in radians
const ANGLE_MAX: f64 = 0.5 * PI;

/// Minimum duty cycle, representing minimum angle (-90 degrees)
const DUTY_CYCLE_MIN: f64 = 0.5;
/// Maximum duty cycle, representing maximum angle (90 degrees)
const DUTY_CYCLE_MAX: f64 = 2.5;

// Structs
/// Provides access to the SG90 servo
#[derive(Debug)]
pub struct SG90 {
    /// RPPAL Pwm pin
    pub pin: Pwm,
    /// Current angle of motor
    angle: f64,
}

impl SG90 {
    /// Initializes the SG90 motor.
    ///
    /// The channel is one of the RPi PWM channels and the angle is the starting angle in radians
    pub fn new(channel: Channel, angle: f64) -> Result<Self, rppal::pwm::Error> {
        let pin = Pwm::with_frequency(
            channel,
            FREQUENCY,
            rad_to_duty_cycle(angle),
            Polarity::Normal,
            true,
        );
        match pin {
            Ok(pin) => Ok(SG90 { pin, angle }),
            Err(_) => Err(rppal::pwm::Error::Io(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Couldn't create PWM channel",
            ))),
        }
    }

    /// Sets the servo to the desired angle (in degrees)
    ///
    /// Accepts only angles in the range allowed by the SG90: -90 degrees to 90 degrees
    pub fn set_angle_deg(&mut self, angle: i32) -> Result<(), rppal::pwm::Error> {
        self.set_angle_rad((angle as f64).to_radians())
    }

    /// Sets the servo to the desired angle (in radians)
    ///
    /// Accepts only angles in the range allowed by the SG90: -0.5 * PI degrees to 0.5 * PI degrees
    pub fn set_angle_rad(&mut self, angle: f64) -> Result<(), rppal::pwm::Error> {
        if !(ANGLE_MIN..=ANGLE_MAX).contains(&angle) {
            Err(rppal::pwm::Error::Io(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Angle not in allowed range of -90 degrees to 90 degrees",
            )))
        } else {
            self.angle = angle;
            self.pin.set_duty_cycle(rad_to_duty_cycle(angle))
        }
    }

    /// Current angle of motor in radians
    pub fn current_angle_rad(&self) -> f64 {
        self.angle
    }

    /// Current angle of motor in degrees
    pub fn current_angle_deg(&self) -> i32 {
        self.angle.to_degrees() as i32
    }
}

// Utility functions
/// Maps numbers from a range to another range
fn map_range<T>(val: T, old_bottom: T, old_top: T, new_bottom: T, new_top: T) -> T
where
    T: Sub<T, Output = T> + Div<T, Output = T> + Mul<T, Output = T> + Add<T, Output = T> + Copy,
{
    (val - old_bottom) / (old_top - old_bottom) * (new_top - new_bottom) + new_bottom
}

/// Maps angle ( [-0.5*PI, 0.5*PI] ) to servo duty cycle in ms ( [0.5, 2.5] )
fn rad_to_servo_range(val: f64) -> f64 {
    map_range(val, ANGLE_MIN, ANGLE_MAX, DUTY_CYCLE_MIN, DUTY_CYCLE_MAX)
}

/// Takes an angle in radians and returns a duty cycle percentage
fn rad_to_duty_cycle(rad: f64) -> f64 {
    // Duty cycle in ms to percentage of period (20ms)
    rad_to_servo_range(rad) / PERIOD
}

#[cfg(test)]
mod tests {
    use crate::*;
    #[test]
    fn test_angle_convert() {
        // 1.5ms / 20
        assert_eq!(0.075f64, rad_to_duty_cycle(0.0));

        // 0.5ms / 20
        assert_eq!(0.025f64, rad_to_duty_cycle(-0.5 * PI));

        // 2.5ms / 20
        assert_eq!(0.125f64, rad_to_duty_cycle(0.5 * PI));
    }
}
